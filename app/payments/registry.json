{
	"name": "payments",
	"type": "registry:block",
	"dependencies": ["@stripe/stripe-js", "lodash", "stripe"],
	"devDependencies": ["@types/dotenv", "@types/lodash", "dotenv", "prisma", "tsx"],
	"registryDependencies": [
		"https://r.gambrell.dev",
		"alert-dialog",
		"button",
		"card",
		"checkbox",
		"command",
		"dialog",
		"input",
		"label",
		"popover",
		"sonner",
		"tabs"
	],
	"files": [
		{
			"path": "./actions/stripe.ts",
			"content": "'use server'\n\nimport { auth } from '@/lib/auth'\nimport { calculateTrialEndUnixTimestamp, CheckoutResponse, createOrRetrieveCustomer, stripe } from '@/lib/stripe'\nimport { getErrorRedirect, getSuccessRedirect, getURL } from '@/lib/utils'\nimport { Price } from '@prisma/client'\nimport Stripe from 'stripe'\n\nexport async function checkoutWithStripe(price: Price): Promise<CheckoutResponse> {\n\ttry {\n\t\tconst user = await auth()\n\n\t\t// Retrieve or create the customer in Stripe\n\t\tlet customer: string\n\t\ttry {\n\t\t\tcustomer = await createOrRetrieveCustomer({ uuid: user.id ?? '', email: user.email ?? '' })\n\t\t} catch (err) {\n\t\t\tconsole.error(err)\n\t\t\tthrow new Error('Unable to access customer record.')\n\t\t}\n\n\t\tlet params: Stripe.Checkout.SessionCreateParams = {\n\t\t\tallow_promotion_codes: true,\n\t\t\tbilling_address_collection: 'required',\n\t\t\tcustomer,\n\t\t\tcustomer_update: {\n\t\t\t\taddress: 'auto',\n\t\t\t},\n\t\t\tline_items: [\n\t\t\t\t{\n\t\t\t\t\tprice: price.id,\n\t\t\t\t\tquantity: 1,\n\t\t\t\t},\n\t\t\t],\n\t\t\tcancel_url: getURL('/plans'),\n\t\t\tsuccess_url: getURL(getSuccessRedirect('/plans', 'Purchase successful.')),\n\t\t}\n\n\t\tparams = {\n\t\t\t...params,\n\t\t\tmode: 'subscription',\n\t\t\tsubscription_data: {\n\t\t\t\ttrial_end: calculateTrialEndUnixTimestamp(price.trial_period_days),\n\t\t\t},\n\t\t}\n\n\t\t// Create a checkout session in Stripe\n\t\tlet session\n\t\ttry {\n\t\t\tsession = await stripe.checkout.sessions.create(params)\n\t\t} catch (err) {\n\t\t\tconsole.error(err)\n\t\t\tthrow new Error('Unable to create checkout session.')\n\t\t}\n\n\t\t// Instead of returning a Response, just return the data or error.\n\t\tif (session) return { sessionId: session.id }\n\t\telse throw new Error('Unable to create checkout session.')\n\t} catch (error) {\n\t\tif (error instanceof Error)\n\t\t\treturn {\n\t\t\t\terrorRedirect: getErrorRedirect('/plans', error.message),\n\t\t\t}\n\t\telse\n\t\t\treturn {\n\t\t\t\terrorRedirect: getErrorRedirect('/plans', 'An unknown error occurred.'),\n\t\t\t}\n\t}\n}\n\nexport async function createStripePortal(currentPath: string) {\n\ttry {\n\t\tconst user = await auth()\n\n\t\tlet customer\n\t\ttry {\n\t\t\tcustomer = await createOrRetrieveCustomer({ uuid: user.id ?? '', email: user.email ?? '' })\n\t\t} catch (err) {\n\t\t\tconsole.error(err)\n\t\t\tthrow new Error('Unable to access customer record.')\n\t\t}\n\n\t\tif (!customer) throw new Error('Could not get customer.')\n\n\t\ttry {\n\t\t\tconst { url } = await stripe.billingPortal.sessions.create({\n\t\t\t\tcustomer,\n\t\t\t\treturn_url: getURL('/plans'),\n\t\t\t})\n\t\t\tif (!url) throw new Error('Could not create billing portal')\n\n\t\t\treturn url\n\t\t} catch (err) {\n\t\t\tconsole.error(err)\n\t\t\tthrow new Error('Could not create billing portal')\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof Error) {\n\t\t\tconsole.error(error)\n\t\t\treturn getErrorRedirect(currentPath, error.message)\n\t\t} else return getErrorRedirect(currentPath, 'An unknown error occurred.')\n\t}\n}\n",
			"type": "registry:example",
			"target": "~/actions/stripe.ts"
		},
		{
			"path": "./app/(protected)/layout.tsx",
			"content": "'use client'\n\nimport { Icons } from '@/components/icons'\nimport { Button } from '@/components/ui/base/c-button'\nimport { ThemeSwitcher } from '@/components/ui/base/theme-switcher'\nimport { LayoutProps } from '@/components/ui/base/types'\nimport { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs'\nimport Link from 'next/link'\nimport { usePathname } from 'next/navigation'\nimport { useState } from 'react'\n\nexport default function Layout({ children }: LayoutProps) {\n\tconst pathname = usePathname()\n\tconst [tab, setTab] = useState(pathname.split('/').pop() ?? 'dashboard')\n\n\treturn (\n\t\t<div className='min-h-screen bg-background relative flex flex-col sm:flex-row sm:items-center sm:justify-center p-4 sm:p-8'>\n\t\t\t<div className='w-full sm:max-w-md grid gap-2'>\n\t\t\t\t<div className='flex gap-4 justify-between'>\n\t\t\t\t\t<Tabs value={tab} onValueChange={setTab}>\n\t\t\t\t\t\t<TabsList>\n\t\t\t\t\t\t\t<TabsTrigger asChild value='dashboard'>\n\t\t\t\t\t\t\t\t<Link href='/dashboard'>Account</Link>\n\t\t\t\t\t\t\t</TabsTrigger>\n\t\t\t\t\t\t\t<TabsTrigger asChild value='accounts'>\n\t\t\t\t\t\t\t\t<Link href='/accounts'>Linked accounts</Link>\n\t\t\t\t\t\t\t</TabsTrigger>\n\t\t\t\t\t\t\t<TabsTrigger asChild value='plans'>\n\t\t\t\t\t\t\t\t<Link href='/plans'>Plans</Link>\n\t\t\t\t\t\t\t</TabsTrigger>\n\t\t\t\t\t\t</TabsList>\n\t\t\t\t\t</Tabs>\n\t\t\t\t\t<ThemeSwitcher>\n\t\t\t\t\t\t<Button variant='ghost'>\n\t\t\t\t\t\t\t<span>Theme</span>\n\t\t\t\t\t\t\t<Icons.chevronDown />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</ThemeSwitcher>\n\t\t\t\t</div>\n\t\t\t\t{children}\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n",
			"type": "registry:example",
			"target": "./app/(protected)/layout.tsx"
		},
		{
			"path": "./app/(protected)/plans/client.tsx",
			"content": "'use client'\n\nimport { checkoutWithStripe, createStripePortal } from '@/actions/stripe'\nimport { ActionButton } from '@/components/ui/base/action-button'\nimport { env } from '@/lib/env'\nimport { getErrorRedirect } from '@/lib/utils'\nimport { Price } from '@prisma/client'\nimport { loadStripe } from '@stripe/stripe-js'\nimport { usePathname, useRouter } from 'next/navigation'\nimport { FormEvent, useState } from 'react'\n\nexport function SubscribeButton({ price }: { price: Price }) {\n\tconst pathname = usePathname()\n\tconst router = useRouter()\n\tconst [isLoading, setIsLoading] = useState(false)\n\n\tconst handleStripeCheckout = async (event: FormEvent<HTMLFormElement>) => {\n\t\tevent.preventDefault()\n\t\tsetIsLoading(true)\n\n\t\tconst { errorRedirect, sessionId } = await checkoutWithStripe(price)\n\n\t\tif (errorRedirect) {\n\t\t\tsetIsLoading(false)\n\t\t\treturn router.push(errorRedirect)\n\t\t}\n\n\t\tif (!sessionId) {\n\t\t\tsetIsLoading(false)\n\t\t\treturn router.push(getErrorRedirect(pathname, 'An unknown error occurred.'))\n\t\t}\n\n\t\tconst stripe = await loadStripe(env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY)\n\t\tstripe?.redirectToCheckout({ sessionId })\n\n\t\tsetIsLoading(false)\n\t}\n\n\treturn (\n\t\t<form onSubmit={handleStripeCheckout}>\n\t\t\t<ActionButton loading={isLoading}>Subscribe</ActionButton>\n\t\t</form>\n\t)\n}\n\nexport function ManageSubscriptionButton() {\n\tconst pathname = usePathname()\n\tconst router = useRouter()\n\tconst [isLoading, setIsLoading] = useState(false)\n\n\tconst handleStripePortalRequest = async (event: FormEvent<HTMLFormElement>) => {\n\t\tevent.preventDefault()\n\t\tsetIsLoading(true)\n\t\tconst redirectUrl = await createStripePortal(pathname)\n\t\tsetIsLoading(false)\n\n\t\treturn router.push(redirectUrl)\n\t}\n\n\treturn (\n\t\t<form onSubmit={handleStripePortalRequest}>\n\t\t\t<ActionButton loading={isLoading} variant='outline'>\n\t\t\t\tManage subscription\n\t\t\t</ActionButton>\n\t\t</form>\n\t)\n}\n",
			"type": "registry:example",
			"target": "./app/(protected)/plans/client.tsx"
		},
		{
			"path": "./app/(protected)/plans/page.tsx",
			"content": "import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'\nimport { auth } from '@/lib/auth'\nimport prisma from '@/lib/db'\nimport * as _ from 'lodash'\nimport { Check } from 'lucide-react'\nimport { ManageSubscriptionButton, SubscribeButton } from './client'\n\ntype ProductMetadata = {\n\tindex: number\n}\n\nexport default async function PlansPage() {\n\tconst user = await auth()\n\tconst products = await prisma.product.findMany({ where: { active: true }, include: { prices: { where: { active: true } } } })\n\n\treturn user.subscriptions.length > 0 ? (\n\t\t<Card className='flex flex-col'>\n\t\t\t<CardHeader>\n\t\t\t\t<CardTitle className='text-2xl font-bold'>{user.subscriptions[0].price?.product?.name}</CardTitle>\n\t\t\t\t<CardDescription className='text-base'>Current plan</CardDescription>\n\t\t\t</CardHeader>\n\t\t\t<CardFooter>\n\t\t\t\t<ManageSubscriptionButton />\n\t\t\t</CardFooter>\n\t\t</Card>\n\t) : (\n\t\t<div className='grid gap-4'>\n\t\t\t{products\n\t\t\t\t.sort((a, b) => Number((a.metadata as ProductMetadata)?.index ?? 0) - Number((b.metadata as ProductMetadata)?.index ?? 0))\n\t\t\t\t.map((product) => (\n\t\t\t\t\t<Card key={product.id} className='flex flex-col'>\n\t\t\t\t\t\t<CardHeader>\n\t\t\t\t\t\t\t<CardTitle className='text-2xl font-bold'>{product.name}</CardTitle>\n\t\t\t\t\t\t\t<CardDescription className='text-base'>{product.description}</CardDescription>\n\t\t\t\t\t\t</CardHeader>\n\t\t\t\t\t\t<CardContent>\n\t\t\t\t\t\t\t<div className='grid gap-2'>\n\t\t\t\t\t\t\t\t<h3 className='font-semibold text-lg'>Features</h3>\n\t\t\t\t\t\t\t\t<ul className='space-y-2'>\n\t\t\t\t\t\t\t\t\t{product.features.map((feature) => (\n\t\t\t\t\t\t\t\t\t\t<li key={feature} className='flex items-center gap-2'>\n\t\t\t\t\t\t\t\t\t\t\t<Check className='h-4 w-4 text-green-500' />\n\t\t\t\t\t\t\t\t\t\t\t<span>{feature}</span>\n\t\t\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</CardContent>\n\t\t\t\t\t\t<CardFooter className='border-t pt-6'>\n\t\t\t\t\t\t\t<div className='grid gap-2 w-full'>\n\t\t\t\t\t\t\t\t<h3 className='font-semibold text-lg'>Pricing</h3>\n\t\t\t\t\t\t\t\t<ul className='space-y-2'>\n\t\t\t\t\t\t\t\t\t{product.prices.map((price) => (\n\t\t\t\t\t\t\t\t\t\t<li key={price.id} className='flex items-center justify-between'>\n\t\t\t\t\t\t\t\t\t\t\t<span className='text-muted-foreground'>{_.capitalize(price.interval ?? '')}ly</span>\n\t\t\t\t\t\t\t\t\t\t\t<span className='font-semibold'>\n\t\t\t\t\t\t\t\t\t\t\t\t{price.unit_amount ? `$${(Number(price.unit_amount) / 100).toFixed(2)}` : 'N/A'}\n\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t<SubscribeButton price={price} />\n\t\t\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t\t\t))}\n\t\t\t\t\t\t\t\t</ul>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</CardFooter>\n\t\t\t\t\t</Card>\n\t\t\t\t))}\n\t\t</div>\n\t)\n}\n",
			"type": "registry:example",
			"target": "./app/(protected)/plans/page.tsx"
		},
		{
			"path": "./app/api/webhooks/stripe/route.ts",
			"content": "import { env } from '@/lib/env'\nimport {\n\tdeletePriceRecord,\n\tdeleteProductRecord,\n\tmanageSubscriptionStatusChange,\n\tstripe,\n\tupsertPriceRecord,\n\tupsertProductRecord,\n} from '@/lib/stripe'\nimport Stripe from 'stripe'\n\nconst relevantEvents = new Set([\n\t'product.created',\n\t'product.updated',\n\t'product.deleted',\n\t'price.created',\n\t'price.updated',\n\t'price.deleted',\n\t'checkout.session.completed',\n\t'customer.subscription.created',\n\t'customer.subscription.updated',\n\t'customer.subscription.deleted',\n])\n\nexport async function POST(req: Request) {\n\tconst body = await req.text()\n\tconst sig = req.headers.get('stripe-signature') as string\n\tconst webhookSecret = env.STRIPE_WEBHOOK_SECRET\n\tlet event: Stripe.Event\n\n\ttry {\n\t\tif (!sig || !webhookSecret) return new Response('Webhook secret not found.', { status: 400 })\n\t\tevent = stripe.webhooks.constructEvent(body, sig, webhookSecret)\n\t\tconsole.log(`🔔  Webhook received: ${event.type}`)\n\t} catch (err: unknown) {\n\t\tconst error = err as Error\n\t\tconsole.log(`❌ Error message: ${error.message}`)\n\t\treturn new Response(`Webhook Error: ${error.message}`, { status: 400 })\n\t}\n\n\tif (relevantEvents.has(event.type)) {\n\t\ttry {\n\t\t\tswitch (event.type) {\n\t\t\t\tcase 'product.created':\n\t\t\t\tcase 'product.updated':\n\t\t\t\t\tawait upsertProductRecord(event.data.object as Stripe.Product)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'price.created':\n\t\t\t\tcase 'price.updated':\n\t\t\t\t\tawait upsertPriceRecord(event.data.object as Stripe.Price)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'price.deleted':\n\t\t\t\t\tawait deletePriceRecord(event.data.object as Stripe.Price)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'product.deleted':\n\t\t\t\t\tawait deleteProductRecord(event.data.object as Stripe.Product)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'customer.subscription.created':\n\t\t\t\tcase 'customer.subscription.updated':\n\t\t\t\tcase 'customer.subscription.deleted':\n\t\t\t\t\tconst subscription = event.data.object as Stripe.Subscription\n\t\t\t\t\tawait manageSubscriptionStatusChange(\n\t\t\t\t\t\tsubscription.id,\n\t\t\t\t\t\tsubscription.customer as string,\n\t\t\t\t\t\tevent.type === 'customer.subscription.created'\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\t\t\t\tcase 'checkout.session.completed':\n\t\t\t\t\tconst checkoutSession = event.data.object as Stripe.Checkout.Session\n\t\t\t\t\tconst subscriptionId = checkoutSession.subscription\n\t\t\t\t\tawait manageSubscriptionStatusChange(subscriptionId as string, checkoutSession.customer as string, true)\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unhandled relevant event!')\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.log(error)\n\t\t\treturn new Response('Webhook handler failed. View your Next.js function logs.', {\n\t\t\t\tstatus: 400,\n\t\t\t})\n\t\t}\n\t} else {\n\t\treturn new Response(`Unsupported event type: ${event.type}`, {\n\t\t\tstatus: 400,\n\t\t})\n\t}\n\treturn new Response(JSON.stringify({ received: true }))\n}\n",
			"type": "registry:example",
			"target": "./app/api/webhooks/stripe/route.ts"
		},
		{
			"path": "./example.env",
			"content": "AUTH_SECRET=\"\"\n\nAUTH_GITHUB_ID=\"\"\nAUTH_GITHUB_SECRET=\"\"\n\nAUTH_GOOGLE_ID=\"\"\nAUTH_GOOGLE_SECRET=\"\"\n\nAUTH_RESEND_KEY=\"\"\nAUTH_RESEND_EMAIL=\"noreply@example.com\"\n\nDATABASE_URL=\"postgresql://postgres:password@localhost:5432/postgres?schema=public\"\n\nSTRIPE_SECRET_KEY=\"sk_test_\"\nSTRIPE_WEBHOOK_SECRET=\"whsec_\"\n\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=\"pk_test_\"\nNEXT_PUBLIC_SITE_URL=\"http://localhost:3000\"\n",
			"type": "registry:example",
			"target": "~/example.env"
		},
		{
			"path": "./lib/auth.ts",
			"content": "import { loginSchema } from '@/validators/auth'\nimport { PrismaAdapter } from '@auth/prisma-adapter'\nimport bcrypt from 'bcryptjs'\nimport NextAuth, { NextAuthConfig } from 'next-auth'\nimport Credentials from 'next-auth/providers/credentials'\nimport Github from 'next-auth/providers/github'\nimport Google from 'next-auth/providers/google'\nimport Resend from 'next-auth/providers/resend'\nimport prisma from './db'\nimport { env } from './env'\nimport { AuthUser } from './utils'\n\nexport const authConfig = {\n\tadapter: PrismaAdapter(prisma),\n\tcallbacks: {\n\t\tauthorized: ({ auth, request: { nextUrl } }) => {\n\t\t\tconst unprotectedRoutes = ['/', '/login', '/register', '/forgot', '/privacy', '/terms']\n\n\t\t\tconst isAuthed = !!auth?.user\n\t\t\tconst isAuthRoute = unprotectedRoutes.includes(nextUrl.pathname)\n\n\t\t\tif (!isAuthRoute) {\n\t\t\t\tif (isAuthed) return true\n\t\t\t\treturn false\n\t\t\t} else if (isAuthed) return Response.redirect(new URL('/dashboard', nextUrl))\n\t\t\treturn true\n\t\t},\n\t},\n\tpages: { signIn: '/login' },\n\tproviders: [\n\t\tCredentials({\n\t\t\tcredentials: { email: {}, password: {} },\n\t\t\tauthorize: async (credentials) => {\n\t\t\t\tconst { email, password } = await loginSchema.parseAsync(credentials)\n\t\t\t\tconst user = await prisma.user.findUnique({ where: { email } })\n\n\t\t\t\tif (!user) throw new Error('User not found')\n\t\t\t\telse if (!user.passwordHash) throw new Error('User does not have a password')\n\t\t\t\telse if (!(await bcrypt.compare(password, user.passwordHash))) throw new Error('Password does not match')\n\n\t\t\t\treturn user\n\t\t\t},\n\t\t}),\n\t\tGithub({ allowDangerousEmailAccountLinking: true }),\n\t\tGoogle({ allowDangerousEmailAccountLinking: true }),\n\t\tResend({ from: env.AUTH_RESEND_EMAIL }),\n\t],\n\tsession: { strategy: 'jwt' },\n} satisfies NextAuthConfig\n\nexport const { handlers, auth: session, signIn, signOut } = NextAuth(authConfig)\n\nexport const auth = async (): Promise<AuthUser> => {\n\tconst session = await NextAuth(authConfig).auth()\n\tif (!session?.user) throw new Error('Not authenticated.')\n\n\tconst user = await prisma.user.findFirst({\n\t\twhere: { email: session.user.email ?? '' },\n\t\tinclude: {\n\t\t\tsubscriptions: {\n\t\t\t\twhere: { status: 'active', price: { active: true, product: { active: true } } },\n\t\t\t\tinclude: { price: { include: { product: true } } },\n\t\t\t},\n\t\t},\n\t})\n\tif (!user) throw new Error('User not found')\n\n\treturn user\n}\n",
			"type": "registry:lib"
		},
		{
			"path": "./lib/env.ts",
			"content": "import { createEnv } from '@t3-oss/env-nextjs'\nimport { z } from 'zod'\n\nexport const env = createEnv({\n\tserver: {\n\t\tAUTH_SECRET: z.string().min(1),\n\n\t\tAUTH_GITHUB_ID: z.string().min(1),\n\t\tAUTH_GITHUB_SECRET: z.string().min(1),\n\n\t\tAUTH_GOOGLE_ID: z.string().min(1),\n\t\tAUTH_GOOGLE_SECRET: z.string().min(1),\n\n\t\tAUTH_RESEND_KEY: z.string().min(1),\n\t\tAUTH_RESEND_EMAIL: z.string().email(),\n\n\t\tDATABASE_URL: z.string().url(),\n\n\t\tSTRIPE_SECRET_KEY: z.string().min(1),\n\t\tSTRIPE_WEBHOOK_SECRET: z.string().min(1),\n\t},\n\tclient: {\n\t\tNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: z.string().min(1),\n\t\tNEXT_PUBLIC_SITE_URL: z.string().url(),\n\t},\n\truntimeEnv: {\n\t\tAUTH_SECRET: process.env.AUTH_SECRET,\n\n\t\tAUTH_GITHUB_ID: process.env.AUTH_GITHUB_ID,\n\t\tAUTH_GITHUB_SECRET: process.env.AUTH_GITHUB_SECRET,\n\n\t\tAUTH_GOOGLE_ID: process.env.AUTH_GOOGLE_ID,\n\t\tAUTH_GOOGLE_SECRET: process.env.AUTH_GOOGLE_SECRET,\n\n\t\tAUTH_RESEND_KEY: process.env.AUTH_RESEND_KEY,\n\t\tAUTH_RESEND_EMAIL: process.env.AUTH_RESEND_EMAIL,\n\n\t\tDATABASE_URL: process.env.DATABASE_URL,\n\n\t\tSTRIPE_SECRET_KEY: process.env.STRIPE_SECRET_KEY,\n\t\tSTRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,\n\n\t\tNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY,\n\t\tNEXT_PUBLIC_SITE_URL: process.env.NEXT_PUBLIC_SITE_URL,\n\t},\n})\n",
			"type": "registry:lib"
		},
		{
			"path": "./lib/stripe.ts",
			"content": "import { Prisma } from '@prisma/client'\nimport Stripe from 'stripe'\nimport prisma from './db'\nimport { env } from './env'\n\nexport const stripe = new Stripe(env.STRIPE_SECRET_KEY, { apiVersion: '2025-03-31.basil' })\n\nexport type CheckoutResponse = {\n\terrorRedirect?: string\n\tsessionId?: string\n}\n\nconst TRIAL_PERIOD_DAYS = 0\n\nconst toDateTime = (secs: number) => {\n\tconst t = new Date(+0)\n\tt.setSeconds(secs)\n\treturn t\n}\n\nexport const calculateTrialEndUnixTimestamp = (trialPeriodDays: number | null | undefined) => {\n\t// Check if trialPeriodDays is null, undefined, or less than 2 days\n\tif (trialPeriodDays === null || trialPeriodDays === undefined || trialPeriodDays < 2) {\n\t\treturn undefined\n\t}\n\n\tconst currentDate = new Date() // Current date and time\n\tconst trialEnd = new Date(currentDate.getTime() + (trialPeriodDays + 1) * 24 * 60 * 60 * 1000) // Add trial days\n\treturn Math.floor(trialEnd.getTime() / 1000) // Convert to Unix timestamp in seconds\n}\n\nexport const upsertProductRecord = async (product: Stripe.Product) => {\n\tconst productData: Prisma.ProductCreateInput = {\n\t\tid: product.id,\n\t\tactive: product.active,\n\t\tname: product.name,\n\t\tdescription: product.description ?? null,\n\t\timage: product.images?.[0] ?? null,\n\t\tmetadata: product.metadata,\n\t\tfeatures: product.marketing_features.filter((f) => f.name).map((f) => f.name!) ?? [],\n\t}\n\n\tawait prisma.product.upsert({ where: { id: product.id }, create: productData, update: productData })\n\tconsole.log(`Product inserted/updated: ${product.id}`)\n}\n\nexport const upsertPriceRecord = async (price: Stripe.Price, retryCount = 0, maxRetries = 3) => {\n\tconst priceData: Prisma.PriceCreateInput = {\n\t\tid: price.id,\n\t\tproduct: { connect: { id: typeof price.product === 'string' ? price.product : '' } },\n\t\tactive: price.active,\n\t\tcurrency: price.currency,\n\t\ttype: price.type,\n\t\tunit_amount: price.unit_amount ?? null,\n\t\tinterval: price.recurring?.interval ?? null,\n\t\tinterval_count: price.recurring?.interval_count ?? null,\n\t\ttrial_period_days: price.recurring?.trial_period_days ?? TRIAL_PERIOD_DAYS,\n\t}\n\n\tawait prisma.price.upsert({ where: { id: price.id }, create: priceData, update: priceData })\n\tconsole.log(`Price inserted/updated: ${price.id}`)\n\n\t// TODO: Might have to use this\n\t// if (upsertError?.message.includes('foreign key constraint')) {\n\t// \tif (retryCount < maxRetries) {\n\t// \t\tconsole.log(`Retry attempt ${retryCount + 1} for price ID: ${price.id}`)\n\t// \t\tawait new Promise((resolve) => setTimeout(resolve, 2000))\n\t// \t\tawait upsertPriceRecord(price, retryCount + 1, maxRetries)\n\t// \t} else {\n\t// \t\tthrow new Error(`Price insert/update failed after ${maxRetries} retries: ${upsertError.message}`)\n\t// \t}\n\t// } else if (upsertError) {\n\t// \tthrow new Error(`Price insert/update failed: ${upsertError.message}`)\n\t// } else {\n\t// console.log(`Price inserted/updated: ${price.id}`)\n\t// }\n}\n\nexport const deleteProductRecord = async (product: Stripe.Product) => {\n\tawait prisma.product.delete({ where: { id: product.id } })\n\tconsole.log(`Product deleted: ${product.id}`)\n}\n\nexport const deletePriceRecord = async (price: Stripe.Price) => {\n\tawait prisma.price.delete({ where: { id: price.id } })\n\tconsole.log(`Price deleted: ${price.id}`)\n}\n\nexport const createCustomerInStripe = async (uuid: string, email: string) => {\n\tconst customerData = { metadata: { user_id: uuid }, email }\n\tconst newCustomer = await stripe.customers.create(customerData)\n\tif (!newCustomer) throw new Error('Stripe customer creation failed.')\n\treturn newCustomer.id\n}\n\nexport const createOrRetrieveCustomer = async ({ email, uuid }: { email: string; uuid: string }) => {\n\t// Check if the customer already exists in Supabase\n\tconst existingUser = await prisma.user.findUnique({ where: { id: uuid } })\n\n\t// Retrieve the Stripe customer ID using the Supabase customer ID, with email fallback\n\tlet stripeCustomerId: string | undefined\n\tif (existingUser?.stripe_customer_id) {\n\t\tconst existingStripeCustomer = await stripe.customers.retrieve(existingUser.stripe_customer_id)\n\t\tstripeCustomerId = existingStripeCustomer.id\n\t} else {\n\t\t// If Stripe ID is missing from Supabase, try to retrieve Stripe customer ID by email\n\t\tconst stripeCustomers = await stripe.customers.list({ email: email })\n\t\tstripeCustomerId = stripeCustomers.data.length ? stripeCustomers.data[0].id : undefined\n\t}\n\n\t// If still no stripeCustomerId, create a new customer in Stripe\n\tconst stripeIdToInsert = stripeCustomerId ? stripeCustomerId : await createCustomerInStripe(uuid, email)\n\tif (!stripeIdToInsert) throw new Error('Stripe customer creation failed.')\n\n\tif (existingUser && stripeCustomerId) {\n\t\t// If Supabase has a record but doesn't match Stripe, update Supabase record\n\t\tif (existingUser.stripe_customer_id !== stripeCustomerId) {\n\t\t\tawait prisma.user.update({ where: { id: uuid }, data: { stripe_customer_id: stripeCustomerId } })\n\t\t\tconsole.warn(`Supabase customer record mismatched Stripe ID. Supabase record updated.`)\n\t\t}\n\t\t// If Supabase has a record and matches Stripe, return Stripe customer ID\n\t\treturn stripeCustomerId\n\t} else {\n\t\tconsole.warn(`Supabase customer record was missing. A new record was created.`)\n\t\tconst upsertedStripeCustomer = await prisma.user.update({ where: { id: uuid }, data: { stripe_customer_id: stripeIdToInsert } })\n\t\treturn upsertedStripeCustomer.stripe_customer_id\n\t}\n}\n\n/**\n * Copies the billing details from the payment method to the customer object.\n */\n\nconst copyBillingDetailsToCustomer = async (uuid: string, payment_method: Stripe.PaymentMethod) => {\n\t//Todo: check this assertion\n\tconst customer = payment_method.customer as string\n\tconst { name, phone, address } = payment_method.billing_details\n\tif (!name || !phone || !address) return\n\n\t//@ts-ignore\n\tawait stripe.customers.update(customer, { name, phone, address })\n\tawait prisma.user.update({\n\t\twhere: { id: uuid },\n\t\tdata: {\n\t\t\tbilling_address: { ...address } as Prisma.InputJsonValue,\n\t\t\tpayment_method: { ...payment_method[payment_method.type] } as Prisma.InputJsonValue,\n\t\t},\n\t})\n}\n\nexport const manageSubscriptionStatusChange = async (subscriptionId: string, customerId: string, createAction = false) => {\n\t// Get customer's UUID from mapping table.\n\tconst customerData = await prisma.user.findUnique({ where: { stripe_customer_id: customerId } })\n\tif (!customerData) throw new Error(`Customer not found: ${customerId}`)\n\n\tconst subscription = await stripe.subscriptions.retrieve(subscriptionId, { expand: ['default_payment_method'] })\n\t// Upsert the latest status of the subscription object.\n\tconst subscriptionData: Prisma.SubscriptionCreateInput = {\n\t\tid: subscription.id,\n\t\tuser: { connect: { id: customerData.id } },\n\t\tmetadata: subscription.metadata,\n\t\tstatus: subscription.status,\n\t\tprice: { connect: { id: subscription.items.data[0].price.id } },\n\t\tcancel_at_period_end: subscription.cancel_at_period_end,\n\t\tcancel_at: subscription.cancel_at ? toDateTime(subscription.cancel_at).toISOString() : null,\n\t\tcanceled_at: subscription.canceled_at ? toDateTime(subscription.canceled_at).toISOString() : null,\n\t\t// TODO: Do these exist?\n\t\t// current_period_start: toDateTime(subscription.current_period_start).toISOString(),\n\t\t// current_period_end: toDateTime(subscription.current_period_end).toISOString(),\n\t\tcreated: toDateTime(subscription.created).toISOString(),\n\t\tended_at: subscription.ended_at ? toDateTime(subscription.ended_at).toISOString() : null,\n\t\ttrial_start: subscription.trial_start ? toDateTime(subscription.trial_start).toISOString() : null,\n\t\ttrial_end: subscription.trial_end ? toDateTime(subscription.trial_end).toISOString() : null,\n\t}\n\n\tawait prisma.subscription.upsert({ where: { id: subscription.id }, create: subscriptionData, update: subscriptionData })\n\tconsole.log(`Inserted/updated subscription [${subscription.id}] for user [${customerData.id}]`)\n\n\t// For a new subscription copy the billing details to the customer object.\n\t// NOTE: This is a costly operation and should happen at the very end.\n\tif (createAction && subscription.default_payment_method)\n\t\tawait copyBillingDetailsToCustomer(customerData.id, subscription.default_payment_method as Stripe.PaymentMethod)\n}\n",
			"type": "registry:lib"
		},
		{
			"path": "./lib/utils.ts",
			"content": "import { Prisma } from '@prisma/client'\nimport { clsx, type ClassValue } from 'clsx'\nimport { twMerge } from 'tailwind-merge'\n\nexport type AuthUser = Prisma.UserGetPayload<{ include: { subscriptions: { include: { price: { include: { product: true } } } } } }>\n\nexport function cn(...inputs: ClassValue[]) {\n\treturn twMerge(clsx(inputs))\n}\n\nexport const getURL = (path: string = '') => {\n\tlet url =\n\t\tprocess?.env?.NEXT_PUBLIC_SITE_URL && process.env.NEXT_PUBLIC_SITE_URL.trim() !== ''\n\t\t\t? process.env.NEXT_PUBLIC_SITE_URL\n\t\t\t: process?.env?.NEXT_PUBLIC_VERCEL_URL && process.env.NEXT_PUBLIC_VERCEL_URL.trim() !== ''\n\t\t\t? process.env.NEXT_PUBLIC_VERCEL_URL\n\t\t\t: 'http://localhost:3000/'\n\n\t// Trim the URL and remove trailing slash if exists.\n\turl = url.replace(/\\/+$/, '')\n\t// Make sure to include `https://` when not localhost.\n\turl = url.includes('http') ? url : `https://${url}`\n\t// Ensure path starts without a slash to avoid double slashes in the final URL.\n\tpath = path.replace(/^\\/+/, '')\n\n\t// Concatenate the URL and the path.\n\treturn path ? `${url}/${path}` : url\n}\n\nconst toastKeyMap = {\n\tblank: 'message',\n\terror: 'error',\n\tsuccess: 'success',\n} as const\n\nconst getToastRedirect = (path: string, type: keyof typeof toastKeyMap, message: string, arbitraryParams: string = '') => {\n\tconst key = toastKeyMap[type]\n\n\tlet redirectPath = `${path}?${key}=${encodeURIComponent(message)}`\n\tif (arbitraryParams) redirectPath += `&${arbitraryParams}`\n\n\treturn redirectPath\n}\n\nexport const getErrorRedirect = (path: string, message: string = '', arbitraryParams: string = '') =>\n\tgetToastRedirect(path, 'error', message, arbitraryParams)\n\nexport const getSuccessRedirect = (path: string, message: string = '', arbitraryParams: string = '') =>\n\tgetToastRedirect(path, 'success', message, arbitraryParams)\n",
			"type": "registry:lib"
		},
		{
			"path": "./prisma/migrations/20250409141510_add_stripe/migration.sql",
			"content": "-- CreateEnum\nCREATE TYPE \"PriceType\" AS ENUM ('one_time', 'recurring');\n\n-- CreateEnum\nCREATE TYPE \"PriceInterval\" AS ENUM ('day', 'week', 'month', 'year');\n\n-- CreateEnum\nCREATE TYPE \"SubscriptionStatus\" AS ENUM ('trialing', 'active', 'canceled', 'incomplete', 'incomplete_expired', 'past_due', 'unpaid', 'paused');\n\n-- AlterTable\nALTER TABLE \"User\" ADD COLUMN     \"stripe_customer_id\" TEXT;\n\n-- CreateTable\nCREATE TABLE \"Price\" (\n    \"id\" TEXT NOT NULL,\n    \"created_at\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"updated_at\" TIMESTAMP(3) NOT NULL,\n    \"product_id\" TEXT,\n    \"active\" BOOLEAN,\n    \"unit_amount\" BIGINT,\n    \"currency\" TEXT,\n    \"type\" \"PriceType\",\n    \"interval\" \"PriceInterval\",\n    \"interval_count\" INTEGER,\n    \"trial_period_days\" INTEGER,\n\n    CONSTRAINT \"Price_pkey\" PRIMARY KEY (\"id\")\n);\n\n-- CreateTable\nCREATE TABLE \"Product\" (\n    \"id\" TEXT NOT NULL,\n    \"created_at\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"updated_at\" TIMESTAMP(3) NOT NULL,\n    \"active\" BOOLEAN,\n    \"name\" TEXT,\n    \"description\" TEXT,\n    \"image\" TEXT,\n    \"metadata\" JSONB,\n\n    CONSTRAINT \"Product_pkey\" PRIMARY KEY (\"id\")\n);\n\n-- CreateTable\nCREATE TABLE \"Subscription\" (\n    \"id\" TEXT NOT NULL,\n    \"created_at\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"updated_at\" TIMESTAMP(3) NOT NULL,\n    \"user_id\" TEXT NOT NULL,\n    \"price_id\" TEXT,\n    \"status\" \"SubscriptionStatus\",\n    \"metadata\" JSONB,\n    \"quantity\" INTEGER,\n    \"cancel_at_period_end\" BOOLEAN,\n    \"created\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"current_period_start\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"current_period_end\" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    \"ended_at\" TIMESTAMP(3),\n    \"cancel_at\" TIMESTAMP(3),\n    \"canceled_at\" TIMESTAMP(3),\n    \"trial_start\" TIMESTAMP(3),\n    \"trial_end\" TIMESTAMP(3),\n\n    CONSTRAINT \"Subscription_pkey\" PRIMARY KEY (\"id\")\n);\n\n-- AddForeignKey\nALTER TABLE \"Price\" ADD CONSTRAINT \"Price_product_id_fkey\" FOREIGN KEY (\"product_id\") REFERENCES \"Product\"(\"id\") ON DELETE SET NULL ON UPDATE CASCADE;\n\n-- AddForeignKey\nALTER TABLE \"Subscription\" ADD CONSTRAINT \"Subscription_user_id_fkey\" FOREIGN KEY (\"user_id\") REFERENCES \"User\"(\"id\") ON DELETE CASCADE ON UPDATE CASCADE;\n\n-- AddForeignKey\nALTER TABLE \"Subscription\" ADD CONSTRAINT \"Subscription_price_id_fkey\" FOREIGN KEY (\"price_id\") REFERENCES \"Price\"(\"id\") ON DELETE SET NULL ON UPDATE CASCADE;\n",
			"type": "registry:example",
			"target": "~/prisma/migrations/20250409141510_add_stripe/migration.sql"
		},
		{
			"path": "./prisma/migrations/20250409143906_unique_customer_id/migration.sql",
			"content": "/*\n  Warnings:\n\n  - A unique constraint covering the columns `[stripe_customer_id]` on the table `User` will be added. If there are existing duplicate values, this will fail.\n\n*/\n-- CreateIndex\nCREATE UNIQUE INDEX \"User_stripe_customer_id_key\" ON \"User\"(\"stripe_customer_id\");\n",
			"type": "registry:example",
			"target": "~/prisma/migrations/20250409143906_unique_customer_id/migration.sql"
		},
		{
			"path": "./prisma/migrations/20250409144338_remove_unused/migration.sql",
			"content": "/*\n  Warnings:\n\n  - You are about to drop the column `quantity` on the `Subscription` table. All the data in the column will be lost.\n\n*/\n-- AlterTable\nALTER TABLE \"Subscription\" DROP COLUMN \"quantity\";\n",
			"type": "registry:example",
			"target": "~/prisma/migrations/20250409144338_remove_unused/migration.sql"
		},
		{
			"path": "./prisma/migrations/20250409144735_add_billing_details/migration.sql",
			"content": "-- AlterTable\nALTER TABLE \"User\" ADD COLUMN     \"billing_address\" JSONB,\nADD COLUMN     \"payment_method\" JSONB;\n",
			"type": "registry:example",
			"target": "~/prisma/migrations/20250409144735_add_billing_details/migration.sql"
		},
		{
			"path": "./prisma/migrations/20250409160755_add_features_to_product/migration.sql",
			"content": "-- AlterTable\nALTER TABLE \"Product\" ADD COLUMN     \"features\" TEXT[] DEFAULT ARRAY[]::TEXT[];\n",
			"type": "registry:example",
			"target": "~/prisma/migrations/20250409160755_add_features_to_product/migration.sql"
		},
		{
			"path": "./prisma/migrations/migration_lock.toml",
			"content": "# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = \"postgresql\"\n",
			"type": "registry:example",
			"target": "~/prisma/migrations/migration_lock.toml"
		},
		{
			"path": "./prisma/schema.prisma",
			"content": "datasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\n// MARK: Stripe\n\nenum PriceType {\n  one_time\n  recurring\n}\n\nenum PriceInterval {\n  day\n  week\n  month\n  year\n}\n\nmodel Price {\n  id         String   @id\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n\n  product_id String?\n  product    Product? @relation(fields: [product_id], references: [id])\n\n  active            Boolean?\n  unit_amount       BigInt?\n  currency          String?\n  type              PriceType?\n  interval          PriceInterval?\n  interval_count    Int?\n  trial_period_days Int?\n\n  subscriptions Subscription[]\n}\n\nmodel Product {\n  id         String   @id\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n\n  active      Boolean?\n  name        String?\n  description String?\n  image       String?\n  metadata    Json?\n  features    String[] @default([])\n\n  prices Price[]\n}\n\nenum SubscriptionStatus {\n  trialing\n  active\n  canceled\n  incomplete\n  incomplete_expired\n  past_due\n  unpaid\n  paused\n}\n\nmodel Subscription {\n  id         String   @id\n  created_at DateTime @default(now())\n  updated_at DateTime @updatedAt\n\n  user_id  String\n  user     User    @relation(fields: [user_id], references: [id], onDelete: Cascade)\n  price_id String?\n  price    Price?  @relation(fields: [price_id], references: [id])\n\n  status               SubscriptionStatus?\n  metadata             Json?\n  cancel_at_period_end Boolean?\n  created              DateTime            @default(now())\n  current_period_start DateTime            @default(now())\n  current_period_end   DateTime            @default(now())\n  ended_at             DateTime?\n  cancel_at            DateTime?\n  canceled_at          DateTime?\n  trial_start          DateTime?\n  trial_end            DateTime?\n}\n\n// MARK: Authentication\n\nmodel User {\n  id        String   @id @default(cuid())\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n\n  name  String?\n  email String  @unique\n  image String?\n\n  stripe_customer_id String? @unique\n  billing_address    Json?\n  payment_method     Json?\n\n  emailVerified DateTime?\n  passwordHash  String?\n\n  subscriptions Subscription[]\n\n  accounts      Account[]\n  sessions      Session[]\n  // Optional for WebAuthn support\n  Authenticator Authenticator[]\n}\n\nmodel Account {\n  userId            String\n  type              String\n  provider          String\n  providerAccountId String\n  refresh_token     String?\n  access_token      String?\n  expires_at        Int?\n  token_type        String?\n  scope             String?\n  id_token          String?\n  session_state     String?\n  createdAt         DateTime @default(now())\n  updatedAt         DateTime @updatedAt\n  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@id([provider, providerAccountId])\n}\n\nmodel Session {\n  sessionToken String   @unique\n  userId       String\n  expires      DateTime\n  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n  createdAt    DateTime @default(now())\n  updatedAt    DateTime @updatedAt\n}\n\nmodel VerificationToken {\n  identifier String\n  token      String\n  expires    DateTime\n\n  @@id([identifier, token])\n}\n\n// Optional for WebAuthn support\nmodel Authenticator {\n  credentialID         String  @unique\n  userId               String\n  providerAccountId    String\n  credentialPublicKey  String\n  counter              Int\n  credentialDeviceType String\n  credentialBackedUp   Boolean\n  transports           String?\n  user                 User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@id([userId, credentialID])\n}\n",
			"type": "registry:example",
			"target": "~/prisma/schema.prisma"
		},
		{
			"path": "./scripts/seed-stripe.ts",
			"content": "import { PriceInterval } from '@prisma/client'\nimport { MetadataParam } from '@stripe/stripe-js'\nimport { config } from 'dotenv'\nimport Stripe from 'stripe'\n\nconfig()\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2025-03-31.basil' })\n\nconst plans: {\n\tname: string\n\tdescription: string\n\tfeatures: string[]\n\tmetadata: MetadataParam\n\tprices: { interval: PriceInterval; unit_amount: number }[]\n}[] = [\n\t{\n\t\tname: 'Basic',\n\t\tdescription: 'This is the basic plan',\n\t\tfeatures: ['Thing 1', 'Thing 2', 'Thing 3'],\n\t\tmetadata: { index: 1 },\n\t\tprices: [\n\t\t\t{ interval: 'month', unit_amount: 499 },\n\t\t\t{ interval: 'year', unit_amount: 4900 },\n\t\t],\n\t},\n\t{\n\t\tname: 'Pro',\n\t\tdescription: 'This is the pro plan',\n\t\tfeatures: ['Thing 4', 'Thing 5', 'Thing 6'],\n\t\tmetadata: { index: 2 },\n\t\tprices: [\n\t\t\t{ interval: 'month', unit_amount: 999 },\n\t\t\t{ interval: 'year', unit_amount: 9900 },\n\t\t],\n\t},\n]\n\nasync function main() {\n\tfor (const plan of plans) {\n\t\tconst p = await stripe.products.create({\n\t\t\tname: plan.name,\n\t\t\tdescription: plan.description,\n\t\t\tmarketing_features: plan.features.map((f) => ({ name: f })),\n\t\t\tmetadata: plan.metadata,\n\t\t})\n\n\t\tfor (const price of plan.prices) {\n\t\t\tawait stripe.prices.create({\n\t\t\t\tproduct: p.id,\n\t\t\t\tcurrency: 'usd',\n\t\t\t\trecurring: { interval: price.interval, interval_count: 1 },\n\t\t\t\tunit_amount: price.unit_amount,\n\t\t\t})\n\t\t}\n\t}\n}\n\nmain()\n",
			"type": "registry:example",
			"target": "~/scripts/seed-stripe.ts"
		}
	],
	"tailwind": {},
	"cssVars": {},
	"meta": {}
}
